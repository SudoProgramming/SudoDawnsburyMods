using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using Dawnsbury.Core.CharacterBuilder.FeatsDb.Common;
using Dawnsbury.Core.CombatActions;
using Dawnsbury.Core.Creatures;
using Dawnsbury.Core.Creatures.Parts;
using Dawnsbury.Core.Mechanics;
using Dawnsbury.Core.Mechanics.Core;
using Dawnsbury.Core.Mechanics.Damage;
using Dawnsbury.Core.Mechanics.Enumerations;
using Dawnsbury.Core.Roller;
using Dawnsbury.Display;
using Dawnsbury.Mods.Feats.Classes.Thaumaturge.RegisteredComponents;

namespace Dawnsbury.Mods.Feats.Classes.Thaumaturge
{
    public class ExploitEffect : QEffect
    {
        public Creature Target { get; set; }

        public Resistance ExploitedWeakness { get; set; }

        public ExploitEffect(Creature owner, Creature defender, bool isGlimpse, Resistance? weakness = null, int antithesisAmount = -1, bool applyToAll = false) : base()
        {
            this.Owner = owner;
            this.ExpiresAt = ExpirationCondition.Never;
            this.Id = ThaumaturgeQEIDs.ExploitVulnerabilityWeakness;
            this.Tag = defender;
            this.Illustration = ThaumaturgeModdedIllustrations.ExploitVulnerabilityBackground;
            this.Name = "Exploit Vulnerability";
            this.Target = defender;
            if (weakness != null)
            {
                SpecialResistance? specialWeakness = null;
                if (weakness is SpecialResistance specialWeak)
                {
                    specialWeakness = specialWeak;
                }

                this.Description = "Exploiting Weakness to all " + defender.BaseName + " - " + (specialWeakness != null ? specialWeakness.Name : weakness.DamageKind.HumanizeLowerCase2()) + " " + weakness.Value;
                this.AddExtraKindedDamageOnStrike = (CombatAction action, Creature damageTarget) =>
                {
                    if ((damageTarget == defender || damageTarget.BaseName == defender.BaseName) || (applyToAll && damageTarget.WeaknessAndResistance.Weaknesses.Any(weak => (weak is SpecialResistance target && weakness is SpecialResistance exploited && target.Name == exploited.Name) || weak.DamageKind == weakness.DamageKind)))
                    {
                        return new KindedDamage(
                            DiceFormula.FromText(specialWeakness != null ? $"{(action.CheckResult != CheckResult.CriticalSuccess ? specialWeakness.Value : Math.Ceiling(specialWeakness.Value / 2.0))}" : "0", "Exploit Vulnerability " + (applyToAll ? "(Sympathetic Vulnerabilities)" : string.Empty) + "- Weakness " + (specialWeakness != null ? $"{specialWeakness.Name} (Weakness Included)" : weakness.DamageKind.HumanizeLowerCase2())),
                            (specialWeakness != null ? DamageKind.Untyped : weakness.DamageKind));
                    }

                    return null;
                };
                this.ExploitedWeakness = weakness;
                this.StateCheck = async (QEffect stateCheck) =>
                {
                    foreach (Creature creature in owner.Battle.AllCreatures.Where(creature => !creature.FriendOf(owner) && creature.BaseName == defender.BaseName))
                    {
                        if (!creature.HasEffect(ThaumaturgeQEIDs.ExploitVulnerabilityTarget) || (creature.FindQEffect(ThaumaturgeQEIDs.ExploitVulnerabilityTarget)?.Tag is Creature a && a == owner))
                        {
                            creature.AddQEffect(new QEffect(ExpirationCondition.Ephemeral)
                            {
                                Id = ThaumaturgeQEIDs.ExploitVulnerabilityTarget,
                                Illustration = ThaumaturgeModdedIllustrations.ExploitVulnerabilityBackground,
                                Name = "Exploited Vulnerability",
                                Description = "Exploited Weakness by " + owner.Name + " - " + (weakness is SpecialResistance changed ? changed.Name : weakness.DamageKind.HumanizeLowerCase2()) + " " + weakness.Value,
                                Tag = owner
                            });
                        }
                    }
                };
            }
            else
            {
                DamageKind damageKind = !isGlimpse ? ThaumaturgeDamageKinds.PersonalAntithesis : ThaumaturgeDamageKinds.GlimpseVulnerability;
                this.Description = "Exploiting Weakness to " + (applyToAll ? "all " + defender.BaseName : defender.Name) + " - " + damageKind.HumanizeTitleCase2() + " " + antithesisAmount;
                this.AddExtraKindedDamageOnStrike = (CombatAction action, Creature damageTarget) =>
                {
                    if (damageTarget == defender || (applyToAll && damageTarget.BaseName == defender.BaseName))
                    {
                        return new KindedDamage(DiceFormula.FromText("0", "Exploit Vulnerability " + (applyToAll ? "(Sympathetic Vulnerabilities)" : string.Empty) + "- " + damageKind.HumanizeTitleCase2()), damageKind);
                    }

                    return null;
                };
                this.StateCheck = async (QEffect stateCheck) =>
                {
                    List<Creature> applyWeaknessTo = new List<Creature>() { defender };

                    if (applyToAll)
                    {
                        applyWeaknessTo.AddRange(owner.Battle.AllCreatures.Where(creature => creature != defender && !creature.FriendOf(owner) && creature.BaseName == defender.BaseName));
                    }

                    foreach (Creature applyWeakness in applyWeaknessTo)
                    {
                        if (!applyWeakness.HasEffect(ThaumaturgeQEIDs.ExploitVulnerabilityTarget) || (applyWeakness.FindQEffect(ThaumaturgeQEIDs.ExploitVulnerabilityTarget)?.Tag is Creature a && a == owner))
                        {
                            applyWeakness.AddQEffect(new QEffect(ExpirationCondition.Ephemeral)
                            {
                                Id = ThaumaturgeQEIDs.ExploitVulnerabilityTarget,
                                Tag = owner,
                                Illustration = ThaumaturgeModdedIllustrations.ExploitVulnerabilityBackground,
                                Name = "Exploited Vulnerability",
                                Description = "Exploited Weakness by " + owner.Name + " - " + damageKind.HumanizeTitleCase2() + " " + antithesisAmount,
                                StateCheck = (QEffect stateCheck) =>
                                {
                                    Creature owner = stateCheck.Owner;
                                    if (owner.HasEffect(ThaumaturgeQEIDs.ExploitVulnerabilityTarget))
                                    {
                                        if (!owner.WeaknessAndResistance.Weaknesses.Any(weakness => weakness.DamageKind == damageKind))
                                        {
                                            owner.WeaknessAndResistance.AddWeakness(damageKind, antithesisAmount);
                                        }
                                    }
                                    else if (owner.WeaknessAndResistance.Weaknesses.Any(weakness => weakness.DamageKind == damageKind))
                                    {
                                        owner.WeaknessAndResistance.Weaknesses.RemoveAll(weakness => weakness.DamageKind == damageKind);
                                    }
                                }
                            });
                        }
                    }
                };
                this.ExploitedWeakness = new Resistance(damageKind, antithesisAmount);
            }

            if (owner.HasFeat(ThaumaturgeFeatNames.MagicalExploits))
            {
                this.YouDealDamageEvent = async (QEffect qfDamageEvent, DamageEvent damageEvent) =>
                {
                    Creature attacker = qfDamageEvent.Owner;
                    CombatAction? action = damageEvent.CombatAction;
                    Creature damageTarget = damageEvent.TargetCreature;

                    if (action != null && attacker.HasFeat(ThaumaturgeFeatNames.MagicalExploits) && action.CheckResult >= CheckResult.Success && action.HasTrait(Trait.Spell) && !action.HasTrait(Trait.SustainASpell) && action.HasTrait(Trait.Attack))
                    {
                        if (weakness != null)
                        {
                            SpecialResistance? specialWeakness = null;
                            if (weakness is SpecialResistance specialWeak)
                            {
                                specialWeakness = specialWeak;
                            }
                            if ((damageTarget == defender || damageTarget.BaseName == defender.BaseName) || (applyToAll && damageTarget.WeaknessAndResistance.Weaknesses.Any(weak => (weak is SpecialResistance target && weakness is SpecialResistance exploited && target.Name == exploited.Name) || weak.DamageKind == weakness.DamageKind)))
                            {
                                if (specialWeakness != null)
                                {
                                    damageEvent.KindedDamages.Add(new KindedDamage(
                                        DiceFormula.FromText(specialWeakness != null ? $"{(action.CheckResult != CheckResult.CriticalSuccess ? specialWeakness.Value : Math.Ceiling(specialWeakness.Value / 2.0))}" : "0", "Exploit Vulnerability " + (applyToAll ? "(Sympathetic Vulnerabilities)" : string.Empty) + "- Weakness " + (specialWeakness != null ? $"{specialWeakness.Name} (Weakness Included)" : weakness.DamageKind.HumanizeLowerCase2())),
                                        (specialWeakness != null ? DamageKind.Untyped : weakness.DamageKind)));
                                }
                                else
                                {
                                    damageEvent.KindedDamages.Add(new KindedDamage(DiceFormula.FromText("0", "Magical Explits"), weakness.DamageKind));
                                }
                            }
                        }
                        else
                        {
                            if (damageTarget == defender || (applyToAll && damageTarget.BaseName == defender.BaseName))
                            {
                                DamageKind damageKind = !isGlimpse ? ThaumaturgeDamageKinds.PersonalAntithesis : ThaumaturgeDamageKinds.GlimpseVulnerability;
                                damageEvent.KindedDamages.Add(new KindedDamage(DiceFormula.FromText("0", "Magical Explits"), damageKind));
                            }
                        }
                    }
                };
            }
        }
    }
}
